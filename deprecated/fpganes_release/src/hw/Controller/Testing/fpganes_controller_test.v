
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module fpganes_controller_test(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
reg cs, rw;
wire addr;
wire iocs, iorw;
wire rda, tbr, rxd, txd, rst_n;
wire[1:0] ioaddr;
reg[2:0] read_count;
wire[7:0] databus, cpubus, rx_data_peek;
reg[7:0] button_states, cpubusr;
reg[13:0] count;
reg[2:0] nstate, state;
wire locked, clk;

localparam START = 3'b000;
localparam WRITE1 = 3'b001;
localparam WRITE0 = 3'b010;
localparam READ = 3'b011;
localparam WAIT = 3'b100;
localparam POSTREAD = 3'b101;


//=======================================================
//  Structural coding
//=======================================================
assign HEX5 = 7'b0101011;
assign HEX4 = 7'b0000110;
assign HEX3 = 7'b0010010;
assign HEX2 = 7'b0101011;
assign HEX1 = 7'b0000110;
assign HEX0 = 7'b0010010;

assign rst_n = KEY[0];

ControllerClockTest clock(
		.refclk(CLOCK_50),   //  refclk.clk
		.rst(~rst_n),      //   reset.reset
		.outclk_0(clk), // outclk0.clk
		.locked(locked)    //  locked.export
	);
/*
spart spart0(
    .clk(clk),
    .rst_n(rst_n),
    .iocs(iocs),
    .iorw(iorw),
    .rda(rda),
    .tbr(tbr),
    .ioaddr(ioaddr),
    .databus(databus),
    .txd(txd),
    .rxd(rxd)
    );

driver driver0(
    .clk(clk),
    .rst_n(rst_n),
    .cs(cs),
    .rw(rw), // low for writes
    .addr(addr),
    .iocs(iocs),
    .iorw(iorw),
    .rda(rda),
    .tbr(tbr),
    .ioaddr(ioaddr),
    .databus(databus),
    .cpubus(cpubus),
	  .rx_data_peek(LEDR[9:2])
	 );*/

	Controller ctrl( .clk(clk), .rst_n(rst_n), .cs(cs), .rw(rw), .addr(addr),  .cpubus(cpubus), .rxd(rxd), .txd(txd), .rx_data_peek(peek));

	wire [7:0] cpb, peek;
	assign cpb = 8'hzz;

assign cpubus = (state == START || state == WAIT || state == READ) ? 8'hzz : cpubusr;

assign addr = 0;

//assign LEDR[1:0] = button_states[1:0];
//assign LEDR[9:2] = rx_data_peek;
assign LEDR[7:0] = button_states;
//assign LEDR[9:8] = (state == START || state == WAIT) ? 2'b11 : (state == WRITE1 || state == WRITE0) ? 2'b01 : (state == READ || state == POSTREAD) ? 2'b10 : 2'b00;

assign rxd = GPIO[31];
assign GPIO[33] = txd;

always @(posedge clk, negedge rst_n) begin
	if (!rst_n)
		state = START;
	else
		state = nstate;
end

always @(*) begin

	nstate = START;
	cs = 1;
	rw = 1;
	cpubusr = 8'hzz;

	case (state)

		START: begin
			nstate = WRITE1;
		end

		WRITE1: begin
			cs = 0;
			rw = 0;
			cpubusr = 8'h01;
			nstate = WRITE0;
		end

		WRITE0: begin
			cs = 0;
			rw = 0;
			cpubusr = 8'h00;
			nstate = READ;
		end

		READ: begin
			cs = 0;
			rw = 1;
			nstate = READ;
			if (read_count == 3'b000)
				button_states[0] = cpubus[0];
			else if (read_count == 3'b001)
				button_states[1] = cpubus[0];
			else if (read_count == 3'b010)
				button_states[2] = cpubus[0];
			else if (read_count == 3'b011)
				button_states[3] = cpubus[0];
			else if (read_count == 3'b100)
				button_states[4] = cpubus[0];
			else if (read_count == 3'b101)
				button_states[5] = cpubus[0];
			else if (read_count == 3'b110)
				button_states[6] = cpubus[0];
			else begin
				button_states[7] = cpubus[0];
				nstate = WAIT;
			end

		end

		POSTREAD: begin
			cs = 0;
			rw = 1;
			button_states[7] = cpubus[0];
			nstate = WAIT;
		end

		WAIT: begin
			if (count == 14'hFFFF)
				nstate = START;
			else
				nstate = WAIT;
		end

		default:
			nstate = START;

	endcase

end

always @(posedge clk, negedge rst_n) begin

	if (!rst_n) begin
		read_count <= 3'b000;
	end
	else if (!rw) begin
		read_count <= 3'b000;
	end
	else begin
		read_count <= read_count + 1;
	end

end

always @(posedge clk, negedge rst_n) begin

	if (!rst_n)
		count <= 0;
	else if (state == WAIT)
		count <= count + 1;
	else
		count <= count;

end


endmodule
